#' @title Function to identify AGE
#'
#' @description Using successively linear regression and decision tree, this function is able to pick AGE from two metric dataset. Originally built to work with the divergence score and the delta count, it is possible to feed the function with other metrics. The decision tree can be also customized.
#'
#' @param divergence_score data frame of the same size as the initial dataset. The divergence score can be computed with the function DivergenceScore.
#' @param delta_count data frame of the same size as the initial dataset. The delta count can be computed with the function DeltaCount.
#' @param SequencingTable a read counts table with the transcripts in row and the samples in column.
#' @param ReconstructedTable the reconstructed table generated by an autoencoder.
#' @param decision_tree function containing a custom decision tree. Check the help of the function my_tree for more informations.
#'
#' @return Data frame containing only rows predicted as AGE.
#' @importFrom stats cooks.distance
#' @importFrom stats dfbetas
#' @importFrom stats hatvalues
#' @importFrom stats lm
#' @importFrom stats rstandard
#' @importFrom stats complete.cases
#' @importFrom progress progress_bar
#' @importFrom solitude isolationForest
#'
#' @examples
#' SequencingTable <- ExampleAbeilleDataSet
#' ReconstructedTable <- ExampleAbeilleReconstructed
#' divergence_score <- DivergenceScore(SequencingTable,ReconstructedTable)
#' delta_count <- DeltaCount(SequencingTable,ReconstructedTable)
#' ages <- IdentifyAGE(divergence_score,delta_count,SequencingTable, ReconstructedTable,
#' decision_tree = my_tree)
#' print(head(ages))
#' @export

IdentifyAGE <- function(divergence_score, delta_count, SequencingTable, ReconstructedTable, decision_tree = my_tree){
  i=1
  var1 <- divergence_score[i,]
  var2 <- delta_count[i,]
  linear_reg <- lm(var2~var1)
  DataReturn <- data.frame(Sample = NA,
                           Transcript = NA,
                           value = NA,
                           reconstruction = NA,
                           divergence_score=NA,
                           delta_count=NA,
                           typeerror=NA,
                           cooksD=NA,
                           hat=NA,
                           dfbetas_intercept=NA,
                           dfbetas_var=NA,
                           predict=NA)
  LinearRegression_data <- data.frame(Sample = colnames(SequencingTable),
                                      Transcript = rep(row.names(SequencingTable)[i],ncol(SequencingTable)),
                                      value = as.numeric(SequencingTable[i,]),
                                      reconstruction = as.numeric(ReconstructedTable[i,]),
                                      divergence_score=var1,
                                      delta_count=var2,
                                      typeerror=rstandard(linear_reg),
                                      cooksD=cooks.distance(linear_reg),
                                      hat=hatvalues(linear_reg),
                                      dfbetas_intercept=dfbetas(linear_reg)[,1],
                                      dfbetas_var=dfbetas(linear_reg)[,2],
                                      row.names = NULL)
  LinearRegression_data['predict'] <- decision_tree(LinearRegression_data)
  LinearRegression_data <- LinearRegression_data[complete.cases(LinearRegression_data),]
  DataReturn <- rbind(DataReturn,LinearRegression_data)
  pb <- progress_bar$new(total = dim(SequencingTable)[1] - 1)
  pb$tick(0)
  for (i in 2:dim(SequencingTable)[1]){
    pb$tick()
    var1 <- divergence_score[i,]
    var2 <- delta_count[i,]
    linear_reg <- lm(var2~var1)
    LinearRegression_data <- data.frame(Sample = colnames(SequencingTable),
                                        Transcript = rep(row.names(SequencingTable)[i],ncol(SequencingTable)),
                                        value = as.numeric(SequencingTable[i,]),
                                        reconstruction = as.numeric(ReconstructedTable[i,]),
                                        divergence_score=var1,
                                        delta_count=var2,
                                        typeerror=rstandard(linear_reg),
                                        cooksD=cooks.distance(linear_reg),
                                        hat=hatvalues(linear_reg),
                                        dfbetas_intercept=dfbetas(linear_reg)[,1],
                                        dfbetas_var=dfbetas(linear_reg)[,2],
                                        row.names = NULL)
    LinearRegression_data['predict'] <- decision_tree(LinearRegression_data)
    LinearRegression_data <- LinearRegression_data[complete.cases(LinearRegression_data), ]
    DataReturn <- rbind(DataReturn,LinearRegression_data)}
  DataReturn <- DataReturn[-1,]
  row.names(DataReturn) <- NULL
  DataReturn <- ComputeAnomalyScore(DataReturn)
  DataReturn <- DataReturn[DataReturn$predict == TRUE,]

  return(DataReturn)
}

#' @section
#'
#' @title Function computing Anomaly Score based on divergence score and delta count.
#'
#' @name ComputeAnomalyScore
#' @description This function is call from the function IdentifyAGE
#'
#' @param my_df data frame containing divergence score and delta count columns. Divergence scores and delta counts can be computed with functions DivergenceScore and DeltaCount of ABEILLE package.
#'
#' @return Data frame with additional column containing anomaly scores.
#'
#' @examples
#'
#' @export

ComputeAnomalyScore <- function(my_df) {
  data_for_iforest <- my_df[,c("divergence_score","delta_count")]
  iforest <- isolationForest$new()
  iforest$fit(data_for_iforest)
  #predict anomaly score
  data_for_iforest$pred <- iforest$predict(data_for_iforest)
  #add the anomaly score to the df of parameters
  my_df$anomaly_score <- data_for_iforest$pred$anomaly_score
  return(my_df)
}
